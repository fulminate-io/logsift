package reducer

import (
	"regexp"
	"slices"
	"sort"
	"strings"
	"time"

	"github.com/fulminate-io/logsift"
)

func init() {
	logsift.RegisterConsolidator(&goStackConsolidator{})
}

type goStackConsolidator struct{}

func (g *goStackConsolidator) Name() string  { return "go_stack" }
func (g *goStackConsolidator) Priority() int { return 10 }

func (g *goStackConsolidator) Consolidate(clusters []logsift.Cluster) []logsift.Cluster {
	var fragments []*logsift.Cluster
	var normal []logsift.Cluster

	for i := range clusters {
		if isGoStackFragment(&clusters[i]) {
			fragments = append(fragments, &clusters[i])
		} else {
			normal = append(normal, clusters[i])
		}
	}

	if len(fragments) < 3 {
		return clusters
	}

	sort.Slice(fragments, func(i, j int) bool {
		return fragments[i].LastSeen.Before(fragments[j].LastSeen)
	})

	var groups [][]*logsift.Cluster
	currentGroup := []*logsift.Cluster{fragments[0]}

	for i := 1; i < len(fragments); i++ {
		prevEnd := currentGroup[len(currentGroup)-1].LastSeen
		if fragments[i].FirstSeen.Sub(prevEnd) <= 30*time.Second {
			currentGroup = append(currentGroup, fragments[i])
		} else {
			groups = append(groups, currentGroup)
			currentGroup = []*logsift.Cluster{fragments[i]}
		}
	}
	groups = append(groups, currentGroup)

	for _, group := range groups {
		if len(group) < 3 {
			for _, c := range group {
				normal = append(normal, *c)
			}
			continue
		}

		merged := logsift.Cluster{
			Template:  "Go runtime crash (goroutine dump)",
			Severity:  logsift.SeverityCritical,
			FirstSeen: group[0].FirstSeen,
			LastSeen:  group[0].LastSeen,
		}

		for _, c := range group {
			merged.Count += c.Count
			if c.FirstSeen.Before(merged.FirstSeen) {
				merged.FirstSeen = c.FirstSeen
			}
			if c.LastSeen.After(merged.LastSeen) {
				merged.LastSeen = c.LastSeen
			}
			if logsift.SeverityIndex(c.Severity) > logsift.SeverityIndex(merged.Severity) {
				merged.Severity = c.Severity
			}
			if len(merged.Examples) < 3 {
				if logsift.ReGoStack.MatchString(c.Template) || logsift.ReExceptionHeader.MatchString(c.Template) {
					ex := c.Template
					if len(c.Examples) > 0 {
						ex = c.Examples[0]
					}
					merged.Examples = append(merged.Examples, ex)
				}
			}
		}

		if len(merged.Examples) == 0 && len(group[0].Examples) > 0 {
			merged.Examples = []string{group[0].Examples[0]}
		} else if len(merged.Examples) == 0 {
			merged.Examples = []string{group[0].Template}
		}

		normal = append(normal, merged)
	}

	return normal
}

var (
	reGoFuncCall      = regexp.MustCompile(`[\w.*/()\-]+\.\w+\(`)
	reGoSourceRef     = regexp.MustCompile(`\.(go|s):\d+`)
	reGoPCOffset      = regexp.MustCompile(`\+0x[0-9a-fA-F]+`)
	reGoRegisterDump  = regexp.MustCompile(`^(rax|rbx|rcx|rdx|rsi|rdi|rbp|rsp|r[89]|r1[0-5]|eax|ebx|ecx|edx|gs|fs|cs|rflags|eflags|rip|eip)\s+0x`)
	reGoCreatedBy     = regexp.MustCompile(`^created by\s+`)
	reGoSignalInfo    = regexp.MustCompile(`^(PC=0x|SIG[A-Z]+[: ]|signal )`)
	reGoAutogenerated = regexp.MustCompile(`^<autogenerated>:\d+`)
)

func normalizeStackLine(msg string) string {
	msg = strings.TrimLeft(msg, " \t")
	msg = strings.TrimPrefix(msg, ">")
	msg = strings.TrimLeft(msg, " \t")
	return msg
}

func isGoStackFragment(c *logsift.Cluster) bool {
	return matchesGoStackPattern(c.Template) ||
		slices.ContainsFunc(c.Examples, matchesGoStackPattern)
}

func matchesGoStackPattern(msg string) bool {
	norm := normalizeStackLine(msg)
	return reGoFuncCall.MatchString(norm) ||
		reGoSourceRef.MatchString(norm) ||
		reGoPCOffset.MatchString(norm) ||
		reGoRegisterDump.MatchString(norm) ||
		logsift.ReGoStack.MatchString(norm) ||
		reGoCreatedBy.MatchString(norm) ||
		reGoSignalInfo.MatchString(norm) ||
		reGoAutogenerated.MatchString(norm)
}
