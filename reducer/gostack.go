package reducer

import (
	"regexp"
	"slices"
	"sort"
	"strings"
	"time"

	"github.com/fulminate-io/logsift"
)

func init() {
	logsift.RegisterConsolidator(&goStackConsolidator{})
}

type goStackConsolidator struct{}

func (g *goStackConsolidator) Name() string  { return "go_stack" }
func (g *goStackConsolidator) Priority() int { return 10 }

func (g *goStackConsolidator) Consolidate(clusters []logsift.Cluster) []logsift.Cluster {
	var fragments []*logsift.Cluster
	var normal []logsift.Cluster

	for i := range clusters {
		if isGoStackFragment(&clusters[i]) {
			fragments = append(fragments, &clusters[i])
		} else {
			normal = append(normal, clusters[i])
		}
	}

	if len(fragments) < 3 {
		return clusters
	}

	sort.Slice(fragments, func(i, j int) bool {
		return fragments[i].LastSeen.Before(fragments[j].LastSeen)
	})

	var groups [][]*logsift.Cluster
	currentGroup := []*logsift.Cluster{fragments[0]}

	for i := 1; i < len(fragments); i++ {
		prevEnd := currentGroup[len(currentGroup)-1].LastSeen
		if fragments[i].FirstSeen.Sub(prevEnd) <= 30*time.Second {
			currentGroup = append(currentGroup, fragments[i])
		} else {
			groups = append(groups, currentGroup)
			currentGroup = []*logsift.Cluster{fragments[i]}
		}
	}
	groups = append(groups, currentGroup)

	for _, group := range groups {
		if len(group) < 3 {
			for _, c := range group {
				normal = append(normal, *c)
			}
			continue
		}

		merged := logsift.Cluster{
			Template:  "Go runtime crash (goroutine dump)",
			Severity:  logsift.SeverityCritical,
			FirstSeen: group[0].FirstSeen,
			LastSeen:  group[0].LastSeen,
		}

		for _, c := range group {
			merged.Count += c.Count
			if c.FirstSeen.Before(merged.FirstSeen) {
				merged.FirstSeen = c.FirstSeen
			}
			if c.LastSeen.After(merged.LastSeen) {
				merged.LastSeen = c.LastSeen
			}
			if logsift.SeverityIndex(c.Severity) > logsift.SeverityIndex(merged.Severity) {
				merged.Severity = c.Severity
			}
			if len(merged.Examples) < 3 {
				if logsift.ReGoStack.MatchString(c.Template) || logsift.ReExceptionHeader.MatchString(c.Template) {
					ex := c.Template
					if len(c.Examples) > 0 {
						ex = c.Examples[0]
					}
					merged.Examples = append(merged.Examples, ex)
				}
			}
		}

		if len(merged.Examples) == 0 && len(group[0].Examples) > 0 {
			merged.Examples = []string{group[0].Examples[0]}
		} else if len(merged.Examples) == 0 {
			merged.Examples = []string{group[0].Template}
		}

		normal = append(normal, merged)
	}

	return normal
}

var (
	// Go function call: "pkg.Func(0xc000...)" — anchored to start of (normalized) line,
	// must have Go-stack-like parenthetical args (hex addrs, ..., ?, {}, or empty).
	// Allows ":" for type:.eq. prefixes.
	reGoFuncCall = regexp.MustCompile(`^[\w.*/()\-:]+\.\w+\(`)
	// Argument content typical of Go stack frames: hex addrs, ..., ?, {hex}, empty parens.
	reGoStackArgs = regexp.MustCompile(`\((0x[0-9a-fA-F]|\.\.\.|\{\}|\)|\{0x|[0-9a-fA-F]+\?|0x)`)
	// Go source file reference: "/path/file.go:NNN" optionally with "+0xNN".
	reGoSourceRef = regexp.MustCompile(`\.go:\d+`)
	reGoSSourceRef = regexp.MustCompile(`\.s:\d+`)
	reGoPCOffset      = regexp.MustCompile(`\+0x[0-9a-fA-F]+`)
	reGoRegisterDump  = regexp.MustCompile(`^(rax|rbx|rcx|rdx|rsi|rdi|rbp|rsp|r[89]|r1[0-5]|eax|ebx|ecx|edx|gs|fs|cs|rflags|eflags|rip|eip)\s+0x`)
	reGoCreatedBy     = regexp.MustCompile(`^created by\s+`)
	reGoSignalInfo    = regexp.MustCompile(`^(PC=0x|SIG[A-Z]+[: ]|signal )`)
	reGoAutogenerated = regexp.MustCompile(`^<autogenerated>:\d+`)
)

func normalizeStackLine(msg string) string {
	msg = strings.TrimLeft(msg, " \t")
	msg = strings.TrimPrefix(msg, ">")
	msg = strings.TrimLeft(msg, " \t")
	return msg
}

func isGoStackFragment(c *logsift.Cluster) bool {
	return matchesGoStackPattern(c.Template) ||
		slices.ContainsFunc(c.Examples, matchesGoStackPattern)
}

func matchesGoStackPattern(msg string) bool {
	norm := normalizeStackLine(msg)
	if len(norm) == 0 {
		return false
	}

	// Never match JSON objects, arrays, or structured log lines.
	if norm[0] == '{' || norm[0] == '[' {
		return false
	}
	// Reject lines that look like timestamped log entries.
	if len(norm) > 4 && norm[0] >= '0' && norm[0] <= '9' && norm[4] == '-' {
		return false
	}
	if strings.HasPrefix(norm, "time=") || strings.HasPrefix(norm, "ts=") {
		return false
	}
	// Reject lines that are clearly natural language or long prose (>300 chars without Go markers).
	if len(norm) > 300 && !reGoSourceRef.MatchString(norm) && !reGoPCOffset.MatchString(norm) {
		return false
	}

	// High-confidence patterns: match directly.
	if logsift.ReGoStack.MatchString(norm) ||
		reGoRegisterDump.MatchString(norm) ||
		reGoCreatedBy.MatchString(norm) ||
		reGoSignalInfo.MatchString(norm) ||
		reGoAutogenerated.MatchString(norm) {
		return true
	}

	// Source file reference: ".go:NNN" — must look like a stack frame line, not a K8s log line.
	// Real stack frames: "  /usr/local/go/src/runtime/panic.go:1038 +0x4a1" or "  /path/file.go:42"
	// False positive: "W0227 18:04:49 12 dispatcher.go:210] Failed calling webhook"
	// Require: line is short and either starts with "/" (path) or has "+0x" (PC offset).
	if reGoSourceRef.MatchString(norm) && len(norm) < 200 {
		if reGoPCOffset.MatchString(norm) {
			return true
		}
		// Bare source ref line: starts with / (path) after optional whitespace.
		trimmed := strings.TrimLeft(norm, " \t")
		if len(trimmed) > 0 && trimmed[0] == '/' {
			return true
		}
	}

	// Assembly source reference: ".s:NNN" with path or PC offset.
	if reGoSSourceRef.MatchString(norm) && len(norm) < 200 {
		if reGoPCOffset.MatchString(norm) {
			return true
		}
		trimmed := strings.TrimLeft(norm, " \t")
		if len(trimmed) > 0 && trimmed[0] == '/' {
			return true
		}
	}

	// Go function call: must start with a qualified name followed by "(" and have
	// stack-like args (hex addrs, ..., ?, {}, empty parens).
	if reGoFuncCall.MatchString(norm) && len(norm) < 300 {
		if reGoStackArgs.MatchString(norm) {
			return true
		}
	}

	return false
}
